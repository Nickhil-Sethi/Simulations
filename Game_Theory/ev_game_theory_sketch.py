import numpy as np 
import Queue 
import copy




'''
Simulates evolutionary dynamics of population with pairwise matching in a symmetric 2x2 game
'''





# population of agents implemented 
# as a binary_search tree

# agent is node in tree



class agent(object):


	def __init__(self,index,strategy):

		if not (strategy == 'C' or strategy == 'D'):
			raise ValueError('strategy takes value in {C,D}')

		
		self.index = index
		self.strategy = strategy
		
		self.left = None
		self.right = None
		self.parent = None




	def children(self):
		
		ch = []

		if self.left:
			ch.append(self.left)
		if self.right:
			ch.append(self.right)

		return ch




	# search the subtree generated by self for s_index
	def search(self,s_index):

		if self.index == s_index:
			
			return self
		
		elif self.index <= s_index:
			
			if self.right:
				return self.right.search(s_index)
			else:
				return None


	

	# insert new agent into subtree spanned by agent
	def insert(self,n_agent):
		
		if not isinstance(n_agent,agent):
			raise TypeError('insert expects type(agent)')

		if self.index == n_agent.index:
			raise IndexError('index already exists')
		if self.index < n_agent.index:
			if not self.right:
				self.right = n_agent
				n_agent.parent = self
			else:
				self.right.insert(n_agent)
		
		else:
			if not self.left:
				self.left = n_agent
				n_agent.parent = self
			else:
				self.left.insert(n_agent)





	def delete(self):
		if not self.children():
			
			if self is self.parent.left:
				self.parent.left = None
			else:	
				self.parent.right = None
		
		elif self.left and not self.right:
			
			self.parent.left = self.left
			self.left.parent = self.parent

		elif self.right and not self.left:
			
			self.parent.right = self.right
			self.right.parent = self.parent

		else:
			current = self.right
			
			while current:
			
				prev = current
				current = current.left
			
			if self is parent.left:
			
				self.parent.left = prev
				prev.parent = self.parent
			
			else:
				self.parent.right = prev
				prev.parent = self.parent





	def inOrder(self):
		
		if not (self.left or self.right):
			return [(self.index,self.strategy)]
		elif self.left and self.right:
			return self.left.inOrder() + [(self.index,self.strategy)] + self.right.inOrder()
		elif self.left and not self.right:
			return self.left.inOrder() + [(self.index,self.strategy)]
		else:
			return [(self.index,self.strategy)] + self.right.inOrder()








class agent_tree(object):

	def __init__(self):
		self.root = None
		self.size = 0




	def insert(self,agent):
		
		self.size += 1

		if not self.root:
			self.root = agent
		else:
			self.root.insert(agent)




	def delete(self,index):

		self.size -= 1 

		if self.root:
			d = self.root.search(index)
			if d:
				d.delete()
		
		if self.size == 0:
			self.root = None




	def select(self,alpha=.01):

		if not self.root:
			raise ValueError('tree empty')

		N = np.floor(alpha*self.size)

		if N%2 != 0:
			N+=1 

		selected = []

		Q = Queue.Queue()
		Q.put(self.root)

		while not Q.empty() and len(selected) < N:

			current = Q.get()

			if np.random.rand() <= alpha:
				selected.append(current)

			for child in current.children():
				Q.put(child)

		return selected



	def randomize(self,indices,start,finish):

		if not len(indices)%2 == 0:
			print len(indices)
			raise ValueError('list must be of even length')

		if finish - start <= 1:

			n = np.random.randint(start+1,finish+1)
			indices[finish],indices[n] = indices[n],indices[finish]
			
			return indices

		# pick a random index
		n = np.random.randint(start+1,finish+1)

		# swap indices[start] and indices[finish]
		indices[finish],indices[n] = indices[n],indices[finish]

		return self.randomize(indices,start+1,finish-1)



	def assign(self,indices):

		N = len(indices)

		M = [0 for i in xrange(N)]
	
		for i in xrange(N):
			M[i] = indices[N-i-1]

		return M



	def match(self,alpha):

		selected = self.select(alpha)

		indices = [agent.index for agent in selected]
		indices = self.randomize(indices,0,len(indices)-1)

		return self.assign(indices)


	def inOrder(self):

		if self.root:
			return self.root.inOrder()
		else:
			return []








# game object
class symmetric_2by2_Game(object):
	
	def __init__(self,a,b,c,d):
		self.normal_form = [[a,b],[c,d]]


	def payoffs(s1,s2):
		if not (s1 in {0,1} and s2 in {0,1}):
			raise ValueError('strategy must be in {0,1}')
		return self.normal_form[s1][s2], self.normal_form[s2][s1]






# simulates evolution of population under
# symmetric 2 by 2 game with random pairwise matching
def simulate(G,simTime=100,initial_size=100,c_fraction=.05,matching_frequency=.04,death_rate = .001):


	# initialize population
	population = agent_tree()

	c_counter = 0
	d_counter = 0

	while population.size < initial_size:
		
		if np.random.rand() <= c_fraction:
			new_agent = agent(population.size,'C')
			c_counter += 1
		else:
			new_agent = agent(population.size,'D')
			d_counter += 1
		
		population.insert(new_agent)


	# simulate population dynamics

	time = 0
	while time < simTime:

		matches = population.match(matching_frequency)

		for pair in matches:
			
			# compute payoffs
			payoffs = G.payoffs(pair[0].strategy,pair[1].strategy)
			
			# insert offspring into population
			for x in {0,1}:
				for i in xrange(payoffs[x]):

					population.insert(agent(population.size+1, pair[x].strategy))
					
					if pair[x].strategy == 'C':
						c_counter += 1
					else:
						d_counter += 1

		frac_c = float(c_counter)/float(c_counter + d_counter)
		frac_d = 1 - frac_c
		
		print frac_c,frac_d

	return






if __name__=='__main__':

	G = symmetric_2by2_Game(10,20,1,5)
	simulate(G)

